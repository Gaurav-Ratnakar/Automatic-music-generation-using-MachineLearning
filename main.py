import keras.backend
import numpy as np
from music21 import *
import os
import numpy as np
from collections import Counter
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
import tensorflow as tf
from tensorflow import keras
from keras.layers import *
from keras.models import *
from keras.callbacks import *
import keras.backend as K
import random
import pygame


# to read MIDI files

def read_midi(file):
    print(' loading music file : ', file)
    notes = []
    notes_to_parse = None

    midi = converter.parse(file)

    # grouping based on instrument

    s2 = instrument.partitionByInstrument(midi)

    for part in s2.parts:
        if 'Piano' in str(part):
            notes_to_parse = part.recurse()
            for element in notes_to_parse:
                if isinstance(element, note.Note):
                    notes.append(str(element.pitch))
                elif isinstance(element, chord.Chord):
                    notes.append('.'.join(str(n) for n in element.normalOrder))

    return np.array(notes)


path = 'dataset/'
files = [i for i in os.listdir(path) if i.endswith('.mid')]
notes_array = np.array([read_midi(path + i) for i in files])

# converting 2d array in 1d
notes_ = [element for note_ in notes_array for element in note_]

unique_notes = list(set(notes_))

freq = dict(Counter(notes_))

# ignoring/ dropping low frequency notes
frequent_notes = [note_ for note_, count in freq.items() if count >= 50]

# generating music files which contain only top frrequency notes

new_music = []
for notes in notes_array:
    temp = []
    for note_ in notes:
        if note_ in frequent_notes:
            temp.append(note_)
    new_music.append(temp)

new_music = np.array(new_music)

# preperation input and output sequences

no_of_timesteps = 32

x = []
y = []

for note_ in new_music:
    for i in range(0, len(note_) - no_of_timesteps, 1):
        input_ = note_[i:i + no_of_timesteps]
        output = note_[i + no_of_timesteps]

        x.append(input_)
        y.append(output)
x = np.array(x)
y = np.array(y)

# Assigning integers to every note

unique_x = list(set(x.ravel()))
x_note_to_int = dict((note_, number) for number, note_ in enumerate(unique_x))

# working on input sequence

x_seq = []
for i in x:
    temp = []
    for j in i:  # assigning unique ids/integer value to every note
        temp.append(x_note_to_int[j])
    x_seq.append(temp)

x_seq = np.array(x_seq)

# Assigning integer to every chord

unique_y = list(set(y))
y_note_to_int = dict((note_, number) for number, note_ in enumerate(unique_y))
y_seq = np.array([y_note_to_int[i] for i in y])

# spliting dataset into test and train

x_tr, x_val, y_tr, y_val = train_test_split(x_seq, y_seq, test_size=0.2, random_state=0)

# --------building the model--------


K.clear_session()
model = Sequential()

model.add(Embedding(len(unique_x), 100, input_length=32, trainable=True))

model.add(Conv1D(64, 3, padding='causal', activation='relu'))
model.add(Dropout(0.2))
model.add(MaxPool1D(2))

model.add(Conv1D(128, 3, activation='relu', dilation_rate=2, padding='causal'))
model.add(Dropout(0.2))
model.add(MaxPool1D(2))

model.add(Conv1D(256, 3, activation='relu', dilation_rate=4, padding='causal'))
model.add(Dropout(0.2))
model.add(MaxPool1D(2))

model.add(GlobalMaxPooling1D())

model.add(Dense(256, activation='relu'))
model.add(Dense(len(unique_x), activation='softmax'))

model.compile(loss='sparse_categorical_crossentropy', optimizer='adam')

model.summary()

mc = ModelCheckpoint('best_model.h5', monitor='val_loss', mode='min', save_best_only=True, verbose=1)

# <------------- TRAINING MODEL --------------------->

history = model.fit(np.array(x_tr), np.array(y_tr), batch_size=128, epochs=50,
                    validation_data=(np.array(x_val), np.array(y_val)), verbose=1, callbacks=[mc])

model = load_model('best_model.h5')

# to compose our music

ind = np.random.randint(0, len(x_val) - 1)
random_music = x_val[ind]
prediction = []

for i in range(10):
    random_music = random_music.reshape(1, no_of_timesteps)

    prob = model.predict(random_music)[0]
    y_pred = np.argmax(prob, axis=0)
    prediction.append(y_pred)

    random_music = np.insert(random_music[0], len(random_music[0]), y_pred)
    random_music = random_music[1:]

# Converting integers back to notes

x_int_to_notes = dict((number, note_) for number, note_ in enumerate(unique_x))
predicted_notes = [x_int_to_notes[i] for i in prediction]


# Converting back to midi file

def convert_to_midi(prediction_output):
    offset = 0
    output_note = []

    # Creating notes and chord based on the values generated by model
    for pattern in prediction_output:
        if ('.' in pattern) or pattern.isdigit():
            notes_in_chord = pattern.split('.')
            notes = []

            for current_note in notes_in_chord:
                cn = int(current_note)
                new_note = note.Note(cn)
                new_note.storedInstrument = instrument.Piano()
                notes.append(new_note)

            new_chord = chord.Chord(notes)
            new_chord.offset = offset
            output_note.append(new_chord)

        else:
            new_note = note.Note(pattern)
            new_note.offset = offset
            new_note.storedInstrument = instrument.Piano()
            output_note.append(new_note)

        offset += 1
    midi_stream = stream.Stream(output_note)
    midi_stream.write('midi', fp='music.mid')


convert_to_midi(predicted_notes)


def play_music(midi_filename):
    '''Stream music_file in a blocking manner'''
    clock = pygame.time.Clock()
    pygame.mixer.music.load(midi_filename)
    pygame.mixer.music.play()
    while pygame.mixer.music.get_busy():
        clock.tick(30)  # check if playback has finished


midi_filename = 'music.mid'

# mixer config
freq = 44100  # audio CD quality
bitsize = -16  # unsigned 16 bit
channels = 2  # 1 is mono, 2 is stereo
buffer = 1024  # number of samples
pygame.mixer.init(freq, bitsize, channels, buffer)

# optional volume 0 to 1.0
pygame.mixer.music.set_volume(0.8)

# listen for interruptions
try:
    # use the midi file you just saved
    play_music(midi_filename)
except KeyboardInterrupt:
    # if user hits Ctrl/C then exit
    # (works only in console mode)
    pygame.mixer.music.fadeout(1000)
    pygame.mixer.music.stop()
    raise SystemExit
